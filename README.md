# Profiling with eBPF
This tool attaches a BPF program to (mostly) each function entry and return in an elf, outputting a trace of these calls/returns.


Note: I'm trying to move some of the loader stuff to rust since it's more ergonomic in some situations (working with different configurations for binaries).

## Dependencies
- gcc
- make
- json-c
- libbpf
- bpftools
- llvm
- clang
- elfutils
- GNU binutils (for nm)
- python3
### Python Deps
- pyelftools
- capstone

## Building
This builds the loader and tests
```sh
./configure.sh # this is to generate the vmlinux.h for your machine
make
```
### For custom binaries
TODO


## Running

You need 3 things to run the loader, an elf, and a json file containing its symbols, and a symbol map generated by `nm`.

The symbol map can be generated with:
```sh
nm -U -v -S path/to/elf > path/to/output_file
```
This is required to generate the json description of the symbols.

The json file can be generated like this:
```sh
python3 scripts/symbols.py path/to/symbolmap path/to/elf path/to/output_file
```

The loader can finally be run with:
```sh
sudo ./build/uprobe -e path/to/elf -s path/to/symbolsjson -o path/to/outputlog
```

Once the loader is running, running the specified elf will cause the loader program to print out traces containing the function name, address, if its a call or return, and PID for each symbol that the loader attached a uprobe bpf to.


# Rust

## Build
You might need some nightly stuff
```
cargo build
```

## Run
```
./target/debug/monitor -e path/to/binary -s path/to/symbols.json <COMMAND> [OPTIONS]
```

